---
title: Database schema under version control
date: 2010-04-22 09:04:04.000000000 +02:00
type: post
published: true
status: publish
categories:
- Development
- MySQL
tags: []
meta:
  _edit_last: '2'
  _sg_subscribe-to-comments: cf@nextep-softwares.com
author:
  login: shlomi
  email: shlomi@openark.org
  display_name: shlomi
  first_name: Shlomi
  last_name: Noach
---
<p>How many organization use version control for development? Probably almost every single one.</p>
<p>How many store the database schema under version control? Alas, not as many.</p>
<p>Coupling one's application with table schema is essential. Organization who actively support multiple versions of the product understand that well. Smaller organizations not always have this realization.</p>
<p>How is it done?</p>
<h4>Ideally</h4>
<p>Ideally one would have:</p>
<ul>
<li>The schema, generated by hand</li>
<li>Essential data (<strong>INSERT INTO</strong> statements for those lookup tables without which you cannot have an application)</li>
<li>Sample data: sufficient real-life data on which to act. This would include customers data, logs, etc.</li>
</ul>
<p>If you can work this way, then creating a staging environment consists of re-creating the entire schema from out schema code, and filling in the essential &amp; sample data.</p>
<p>The thing with this method is that one does not (usually?) apply it on one's live system. Say we were to add a column. On our live servers we would issue an <strong>ALTER TABLE t ADD COLUMN</strong>.</p>
<p>But this means we're using different methods on our staging server and on our production server.</p>
<h4>Incremental</h4>
<p>Another kind of solution would be to hold:</p>
<ul>
<li>The static schema, as before</li>
<li>Essential data, as before</li>
<li>Sample data, as before</li>
<li>A migration script, which is the concatenation of all ALTERs, CREATEs etc. as of the static schema.</li>
</ul>
<p>Once in a while one can do a "reset", and update the static schema with the existing design.</p>
<h4>As you go along</h4>
<p>This solution simply means "we apply the changes on staging; test + version them; then apply on production".</p>
<p>A side effect of this solution is that the database generates the schema, but the schema does not generate the database as in previous cases. This makes for an uglier solution, where you first apply the changes to the database, and then, based on what the database report, enter data into the version control.</p>
<p>How to do that? Easiest would be to use <strong>mysqldump --routines --no-data</strong>. Some further parsing should be done to strip out the <strong>AUTO_INCREMENT</strong> values, which tend to change, as well as the surrounding variables settings (strip out the character set settings etc.).</p>
<h4>Summary</h4>
<p>However you do it, make sure you have some kind of version control on your schema. It pays off just as with doing version control for your code. You get to compare, understand the incremental changes, understand the change in design, etc.</p>
