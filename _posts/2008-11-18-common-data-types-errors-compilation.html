---
title: Common wrong Data Types compilation
date: 2008-11-18 09:37:57.000000000 +01:00
type: post
published: true
status: publish
categories:
- MySQL
tags:
- Data Types
- Normalization
- Schema
meta:
  _edit_last: '2'
  _sg_subscribe-to-comments: robert.egan@saffrondigital.com
author:
  login: shlomi
  email: shlomi@openark.org
  display_name: shlomi
  first_name: Shlomi
  last_name: Noach
excerpt: "During my work with companies using MySQL, I have encountered many issues
  with regard to schema design, normalization and indexing. Of the most common errors
  are incorrect data types definition. \r\n\r\nHere's a compilation of \"the right
  and the wrong\" data types."
---
<p>During my work with companies using MySQL, I have encountered many issues with regard to schema design, normalization and indexing. Of the most common errors are incorrect data types definition. Many times the database is designed by programmers or otherwise non-expert DBAs. Some companies do not have the time and cannot spare the effort of redesigning and refactoring their databases, and eventually face poor performance issues.</p>
<p>Here's a compilation of "the right and the wrong" data types.<!--more--></p>
<ul>
<li><strong><code>INT(1)</code></strong> is not one byte long. <strong><code>INT(10)</code></strong> is no bigger than <strong><code>INT(2)</code></strong>. The number in parenthesis is misleading, and only describes the text alignment of the number, when displayed in an interactive shell. All mentioned types are the same INT, have the same storage capacity, and the same range. If you want a one-byte <strong><code>INT</code></strong>, use <strong><code>TINYINT</code></strong>.</li>
</ul>
<ul>
<li>An integer <strong><code>PRIMARY KEY</code></strong> is preferable, especially if you're using the InnoDB storage engine. If possible, avoid using <strong><code>VARCHAR</code></strong> as <strong><code>PRIMARY KEY</code></strong>. In InnoDB, this will make the clustered index deeper, secondary indexes larger (sometimes much larger) and look ups slower.</li>
</ul>
<ul>
<li>Do not use <strong><code>VARCHAR</code></strong> to represent timestamps. It may look like <strong><code>'2008-11-14 07:59:13'</code></strong> is a textual field, but in fact it's just an integer counting the seconds elapsed from 1970-01-01. That's 4 bytes vs. 19 if you're using <strong><code>CHAR</code></strong> with <strong><code>ASCII</code></strong> charset, or more if you're using <strong><code>UTF8</code></strong> or <strong><code>VARCHAR</code></strong>.</li>
</ul>
<ul>
<li>Do not use <strong><code>VARCHAR</code></strong> to represent IPv4 addresses. This one is quite common. The IP 192.168.100.255 can be represented with <strong><code>VARCHAR(15)</code></strong>, true, but could be better represented with a 4-byte int. That's what IPv4 is: four bytes. Use the <strong><code>INET_ATON()</code></strong> and <strong><code>INET_NTOA()</code></strong> functions to translate between the INT value and textual value.</li>
</ul>
<ul>
<li>This one should be obvious, but I've seen it in reality, where the schema was auto generated by some naive generator: do not represent numbers as text. Yes, I have seen integer columns represented by <strong><code>VARCHAR</code></strong>. Don't ask how the performance was.</li>
</ul>
<ul>
<li><strong><code>MD5()</code></strong> columns shouldn't be <strong><code>VARCHAR</code></strong>. Use <strong><code>CHAR(32)</code></strong> instead. It's always 32 bytes long, so no need for <strong><code>VARCHAR</code></strong>'s additional byte overhead. If your tables or database are <strong><code>UTF8</code></strong> by default, make sure the MD5 column's charset is <strong><code>ASCII</code></strong>, or it will consume 96 bytes instead of just 32. I also suggest the case-sensitive <strong><code>ascii_bin</code></strong> collation, but that's a more minor issue.</li>
</ul>
<ul>
<li><strong><code>PASSWORD()</code></strong> columns shouldn't be <strong><code>VARCHAR</code></strong>, but <strong><code>CHAR</code></strong>. The length depends on whether you're using <strong><code>old-passwords</code></strong> variable (for some strange reason, this variable always appears in the MySQL sample configuration files - though you really don't want it unless it's for backward compatibility with older MySQL versions). As in the MD5 note, use <strong><code>ASCII</code></strong> charset.</li>
</ul>
<ul>
<li>Better use <strong><code>TIMESTAMP</code></strong> than <strong><code>INT</code></strong> to count seconds, as MySQL has many supportive functions for this data type.</li>
</ul>
<ul>
<li>Use <strong><code>TINYINT</code></strong>, <strong><code>SMALLINT</code></strong>, <strong><code>MEDIUMINT</code></strong> instead of <strong><code>INT</code></strong> when possible. Do you expect to have 4000000000 customers? No? Then a "<strong><code>id SMALLINT</code></strong>" may suffice as <strong><code>PRIMARY KEY</code></strong>.</li>
</ul>
<ul>
<li>Use <strong><code>CHARACTER SET</code></strong>s with care. More on this on future posts.</li>
</ul>
