---
title: The DB problem inherent to dynamic web pages
date: 2009-07-20 13:48:56.000000000 +02:00
type: post
published: true
status: publish
categories:
- MySQL
tags:
- Java
- Web
meta:
  _edit_last: '2'
  _sg_subscribe-to-comments: roland.bouman@gmail.com
author:
  login: shlomi
  email: shlomi@openark.org
  display_name: shlomi
  first_name: Shlomi
  last_name: Noach
---
<p>When building web sites, a popular demand is a maximum page load time.</p>
<p>For example, many would require &lt; 0.5 seconds (or even less) for major pages loading time. Of course, there are numerous factors for page load time: network, caching, web servers, scripting language/code, database access and more.</p>
<p>Naturally I want to discuss the use of database access when creating web pages. I'll be referring to dynamic web pages, such that are created by common languages as PHP, Java/J2EE, Ruby, ASP(.NET) etc.</p>
<p>A very common programming style is - what's called in the Java jargon - using "scriptlets" as in the following JSP page:</p>
<blockquote>
<pre>&lt;html&gt;
&lt;body&gt;
    Time now is &lt;%= new java.util.Date() %&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
</blockquote>
<p>The above replaces the "<em>&lt;%= new java.util.Date() %&gt;</em>" part with a text representation of the current time.</p>
<p>If I were to produce a dynamic content site, say, a WordPress blog, like the one you're reading, I would need to generate several dynamic contents: the latest posts, the popular tags, the comments for this post, etc. These are generated by calling upon the database and running some queries. I suppose there's nothing new in what I've explained so far.</p>
<h4>The problem</h4>
<p>When generating a "heavyweight" page, like some online newspaper or bookstore, there may be many queries involved. Are you logged in? Do we have recommendations for you? What are the latest topics? What have you been interested in before? Do you have friends online? What content have you produced on the website?</p>
<p><!--more-->I've recently reviewed a site which generated &gt; 500 queries per single page. I personally thought that was a very high number, but that was a necessity. The problem was: the page took 2 seconds to load.</p>
<p>Some tuning, rewriting and indexing later, time dropped to 0.6 seconds to load; but that was not fast enough. It was then that we got to a major conclusion:</p>
<blockquote><p>All database calls are serialized. They need to be parallelized.</p></blockquote>
<p>Remember that MySQL can only utilize a single thread for the computation of a single query (though more threads can handle IO in the meantime). This leads to only one CPU being used on your standard Linux distribution, for a given web page.</p>
<p>Really, that sounds just too obvious! But not so easy to achieve when doing "scriptlets". The templating engine parses the scriptlets one by one, executing them in order. In fact, you assume it does so, so that you can rely on the outcome of the previous scriptlet in the next one. In Java, for example, it goes beyond that: a JSP page is rewritten as a normal Java Servlet class, where the "scriptlets" become the main code, and the HTML becomes just printing to standard output. So you get linear executing code.</p>
<p>Even with more sophisticated frameworks, the "normal" way of doing things is linear. For example, using the Spring framework, you have Java objects -- controllers -- which are responsible for web pages. You can avoid doing scpriting within your dynamic web pages, and only ask for data provided by those controllers. So, for example, using <a href="http://www.springsource.org/">Spring</a> + <a href="http://velocity.apache.org/">Velocity</a>, a web page could look like this:</p>
<blockquote>
<pre>&lt;html&gt;
&lt;body&gt;
    Login time as recorded in DB is: ${user.loginTime}
&lt;/body&gt;
&lt;/html&gt;</pre>
</blockquote>
<p>This (usually) translates to calling the <em>getLoginTime()</em> method on a pre-built <em>user</em> object. But just how does this method work?</p>
<ul>
<li>Does it do lazy initialization, so that it calls upon the DB to get the answer?</li>
<li>Did the controller set up the value during some init() method?</li>
<li>Did the controller set up the value in response to the web page's request parameter, parsing them one by one?</li>
</ul>
<p>All the above options lead to linear, or serial execution.</p>
<h4>How to parallelize?</h4>
<p>Parallelization with web pages is not so simple, and requires understanding of multi threading programming. The programmer needs to be aware of race conditions, deadlocks, starvation issues, etc. (though, to be honest, in dynamic web pages context these do not usually become a real issue). Some programming languages provide good support for multi threaded programming. Java is one such language.</p>
<p>Let's assume, then, that we need to spawn some 10 queries in response to a page request. With Jjava, we can write something like:</p>
<blockquote>
<pre>CountDownLatch doneSignal = <strong>new</strong> CountDownLatch(10);

Runnable task1 = <strong>new</strong> Runnable() {
    <strong>public</strong> <strong>void</strong> run()
    {
        user.setLoginTime(<strong>this</strong>.jdbcTemplate.queryForInt("SELECT ... FROM ..."));
        doneSignal.countDown();
    }
} ;

Runnable task2 = <strong>new</strong> Runnable() {
    <strong>public</strong> <strong>void</strong> run()
    {
        headlines = getSimpleJdbcTemplate().query("SELECT * FROM headline WHERE...",
            <strong>new</strong> ParameterizedRowMapper&lt;Headline&gt;() {
                <strong>public</strong> Headline mapRow(ResultSet rs, <strong>int</strong> rowNum)
                {
                    Headline headline = <strong>new</strong> Headline();
                    headline.setTitle(rs.getString("title");
                    headline.setUrl(rs.getString("url");
                    ...
                }
            }
        doneSignal.countDown();
    }
} ;

...

Runnable task10 = <strong>new</strong> Runnable() {
    ...
    doneSignal.countDown();
}
Executor executor = Executors.newFixedThreadPool(numberOfAvailableProcessors);
executor.execute(task1);
...
executor.execute(task10);

doneSignal.await();

// Now fill in the Model</pre>
</blockquote>
<p>The above code is simplified and presented in a way which is more readable. What it says is:</p>
<ul>
<li>Let's create the 10 tasks, but not execute them: just lay out the commands.</li>
<li>Each task, upon completion, lets the <strong>CountDownLatch</strong> know it has completed (but remeber we have not executed it yet).</li>
<li>We create or use a thread pool, using some <em>n</em> threads; <em>n</em> may relate to the number of processors we have.</li>
<li>We ask the pool to execute all threads. At the discretion of the pool, it will either run them all concurrently, or some sequentially - depending on how many threads are available.</li>
<li>We ask the <strong>CountDownLatch</strong> -- a one-time <em>barrier</em> -- to block, until all 10 tasks have notified they're done.</li>
<li>We can now go on and do our stuff.</li>
</ul>
<p>Spring has a built in <a href="http://static.springsource.org/spring/docs/2.5.x/reference/scheduling.html#scheduling-task-executor">TaskExecutor</a> mechanism to provide solution similar to the thread pool above.</p>
<p>I'm mostly a C/C++/Java programmer; I have no knowledge on how this can be achieved in PHP, Ruby, ASP.NET or other languages. The above code is certainly not the most straightforward to use. I would like to see frameworks provide wrappers for this kind of solution, so as to support the common web developer with parallelization.</p>
